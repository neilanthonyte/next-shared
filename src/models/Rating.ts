import { ISerializable } from "../types/ISerializable";
import { unixTimestamp } from "next-shared/src/types/dateTypes";
import { cloneModelObject } from "../helpers/cloneModelObject";

import { IsString, IsInt, IsOptional, validate } from "class-validator";
import { ValidationError } from "../helpers/errorTypes";

export interface IRatingsAggregateQuery {
  from: unixTimestamp;
  to: unixTimestamp;
  filters: {
    rateeType: string;
    rateeId?: string | string[];
    sourceType?: string;
    sourceId?: string;
    raterType?: string;
    raterId?: string;
  };
  groupBy?: "ratee" | "rater";
}

export interface IAggregateResponse {
  count: number;
  average: number;
  rateeId?: string;
  raterId?: string;
}

export class Rating implements ISerializable {
  /** Generated by the database */
  @IsOptional()
  @IsInt()
  public id?: string;

  /**
   * The date when the rating was submitted, not inserted.
   *
   * @note this a unix timestamp!
   */
  @IsInt()
  public dateSubmitted: unixTimestamp;

  /**
   * The type of what is currently being rated.
   * e.g. clinic, practitioner, company, etc.
   *
   * @example clinic, practitioner
   */
  @IsString()
  public rateeType: string;

  /**
   * Identifying value for the rateeType.
   * e.g. if the `rateeType` is a clinic, the `rateeId` might be `next-head-office-dev`
   */
  @IsOptional()
  @IsString()
  public rateeId?: string;

  /**
   * Origin of the rating, e.g. Form, direct, google, etc.
   * This is used to trace back where the rating has come from.
   */
  @IsString()
  public sourceType: string;

  /**
   * Identifying value for the Source_type, e.g. Form submission ID.
   *
   * e.g. If the form submission service is used to submit the value,
   * then sourceId would be the ID of that form entry in the database
   */
  @IsOptional()
  @IsString()
  public sourceId?: string;

  /**
   * An optional comment to associate with the rating.
   */
  @IsOptional()
  @IsString()
  public comment?: string;

  /** Minimum value set by the external rating system, e.g. 1 */
  @IsInt()
  public rawMin: number;

  /** Minimum value set by the external collector, e.g. 4 */
  @IsInt()
  public rawMax: number;

  /** Actual rating as set by the external collector, e.g. 2.2 */
  @IsInt()
  public rawRating: number;

  /**
   * The standardised rating between a certain min and max.
   * On a rating insert, this will be generated by services.
   */
  @IsOptional()
  @IsInt()
  public rating?: number;

  /** Who the rating has come from, e.g. patient, customer, etc. */
  @IsOptional()
  @IsString()
  public raterType?: string;

  /** Identifying value for the Rater_Type, e.g. for a rater type of patient in the next system, this would be a patient ID. */
  @IsOptional()
  @IsString()
  public raterId?: string;

  /**
   * Free-form object that can be used to insert meta data alongside a rating.
   * An example is an appointment id when rating a patient advocate.
   */
  @IsOptional()
  public meta?: { [key: string]: any };

  public filterSensitiveData() {
    const clone = cloneModelObject(this);
    return clone;
  }

  public static unserialize(rating: any) {
    const newRating = new Rating();

    newRating.rateeId = rating.rateeId;
    newRating.dateSubmitted = rating.dateSubmitted;
    newRating.rateeType = rating.rateeType;
    newRating.raterId = rating.raterId;
    newRating.raterType = rating.raterType;
    newRating.rating = rating.rating;
    newRating.rawMax = rating.rawMax;
    newRating.rawMin = rating.rawMin;
    newRating.rawRating = rating.rawRating;
    newRating.sourceId = rating.sourceId;
    newRating.sourceType = rating.sourceType;
    newRating.comment = rating.comment;
    newRating.meta = rating.meta;

    return newRating;
  }

  public async validate() {
    const isInvalid = await validate(this, {
      validationError: { target: false },
    });
    if (isInvalid.length > 0) {
      throw new ValidationError(isInvalid);
    }
    // additional check to ensure that raw ratings are within their own bounds
    if (this.rawRating > this.rawMax || this.rawRating < this.rawMin) {
      throw new ValidationError("rawRating must be within the raw min and max");
    }
  }

  public serialize() {
    return {
      id: this.id,
      dateSubmitted: this.dateSubmitted,
      rateeType: this.rateeType,
      rateeId: this.rateeId,
      sourceType: this.sourceType,
      sourceId: this.sourceId,
      comment: this.comment,
      rawMin: this.rawMin,
      rawMax: this.rawMax,
      rawRating: this.rawRating,
      rating: this.rating,
      raterType: this.raterType,
      raterId: this.raterId,
      meta: this.meta,
    };
  }
}
